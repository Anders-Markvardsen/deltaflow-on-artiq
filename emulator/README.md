# emulator

## General notes

A virtualized ARTIQ-platform emulator. 
The emulator relies on emulated blocks (or1ksim) as well as simulated ones 
(verilated code) plus a set of models written in SystemC. 

![Structure of the emulator - Diagram](/docs/emulator_in_depth.png)

## How is constructed

1. Following the standard ARTIQ approach, a platform (virtualKasli) is defined in migen. Refer to [SoCBuilder](SoCBuilder/README.md) for more information. 
2. The migen toolchain generates two types of outputs, gateware and software. `build/artiq_kasli/gateware` contains all the files required for synthetizing the design on FPGA. The emulator uses `top.v` (a single verilog file that describes all the FPGA logic) to function. The software instead is generated by compiling the standard ARTIQ firmware (contained in `emulator/artiq/artiq/firmware`) via the rust toolchain. The toolchain has compile flags in the form of `#[cfg(has_x)]` that can be used to selectively compile portions of the code. Those values are derived from the migen representation and passed to the compiler via `build/artiq_kasli/software/include/generated/rust-cfg`. Likewise, the information contained in `build/artiq_kasli/software/include/generated/csr.rs` and `build/artiq_kasli/software/include/generated/mem.rs` will be used to generate custom firmware.
3. The rust compilation produces four outputs (i.e. that are used in the emulator). 
  1. `build/artiq_kasli/software/bootloader/bootloader.elf`. This file contains the bootloader code that the main cpu uses at time zero to perform the startup actions. The associated code has been optimized for the emulator. `#[cfg(has_emulator)]` compiler directives have been used to speed-up/ignore hardware specific phases (e.g. DDR initialization)
  1. `build/artiq_kasli/software/runtime/runtime.bin`. This file contains the proper run-time image. This is loaded by the bootloader (Note: the full artiq system allows boot from network). This image is normally stored in flash memory and passed to DDR memory (after CRC-checks) where it will reside. In the emulator we are skipping this phase and loading it directly in DDR memory at time zero (the bootloader does not uses the DDR memory in our implementation). The Rabi-demo is currently embedded in the rust code and executed as part of the runtime sequence. 
  1. `build/startup_kernel.elf`. This image contains a simple experiment that uses the artiq-deltaflow interface to parse deltagraph requests (HAL commands) and pass them to the RTIO. This image is generated by the ARTIQ toolchain starting from `SoCBuilder/startup_kernel.py` and compiled into the correspondent elf file via the ARTIQ command `artiq_compile.py`. Within the runtime sequence, the main CPU copies this image from the flash memory, copies in DDR (and/or l2 cache) and performs a dynamic relocation of its content to produce the correct execution trace. The Kernel CPU that has been sitting idle, is not enabled and it will start fetching instructions from the memory location (DDR) in which the startup_kernel has been loaded. 
  1. `build/idle_kernel.elf`. Similarly to the startup_kernel this file is generated from `SoCBuilder/idle_kernel.py` and executed if there is no active network connection at the end of the sequence.
4. The `top.v` generated at point 2. is converted into a SystemC representation via verilator [verilator](https://github.com/verilator/verilator). This conversion preserves the "hardware" nature of the verilog constructs, preserving clocks, parallel execution etc. Compared to a traditional "FPGA-simulation" there is a visible speed-up in terms of execution time.
5. The `emulator/deltaflow_emulator.cpp` is the top-level of the SystemC run. It contains the verilated `top.v` (that becomes `SoC.cpp`), the SystemC representation of the Rabi-demo Deltagraph and all the models and libraries required to mimick all the peripherals connected to the real ARTIQ system (defined in `deltamodels` and [misoc_models](misoc_models/README.md) ).  
6. The `emulator/quantum_interface.hpp` defines a basic implementation of a conversion from single-bits control to a quantum command. In this implementation it deserializes the quantum command (received from a TTLOutput) into a format that a quantum simulator can digest.

