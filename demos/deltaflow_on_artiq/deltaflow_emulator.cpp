#include <systemc>
#include "/workdir/emulator/artiq_emulator.hpp"
// Options parsing
#include "cxxopts/cxxopts.hpp"

// Autogenerated blocks
#include "build/rabi_demo.h"

#include <exception>
#include <typeinfo>
#include <stdexcept>

#include <getopt.h>
// For clock generation
#include "deltamodels/commons/testbench_utils.hpp"

using namespace std;

#define STEP_SIZE 100
#define CLOCK_PERIOD 1.0

int sc_main(int argc, char** argv) {
    Py_Initialize();
    cxxopts::Options options("ArtiqDeltaflowEmulator", "Emulator for the ARTIQ System");
    options.positional_help("[optional args]").show_positional_help();
    options.add_options()
        ("help", "Print help")
        ("duration", "Simulation Duration [us]", cxxopts::value<int>()->default_value("600"))
        ("trace-from", "Start of deep tracing [us]", cxxopts::value<int>()->default_value("-1"));
    auto args = options.parse(argc, (const char**&) argv);
    
    if (args.count("help"))
    {
      std::cout << options.help() << std::endl;
      exit(0);
    }

    int sim_duration = args["duration"].as<int>();
    int tracing_delay = args["trace-from"].as<int>();

    sc_trace_file *Tf = sc_create_vcd_trace_file("/workdir/trace_kasli_deltaflow_and_emulator");
    
    // Riverlane HAL interface
    sc_signal<sc_bv<32>> hal_cmd;
    sc_trace(Tf, hal_cmd, "hal_cmd");
    sc_signal<sc_bv<1>> hal_cmd_valid;
    sc_trace(Tf, hal_cmd_valid, "hal_cmd_valid");
    sc_signal<sc_bv<1>> hal_cmd_ready;
    sc_trace(Tf, hal_cmd_ready, "hal_cmd_ready");
    sc_signal<sc_bv<32>> hal_readout;
    sc_trace(Tf, hal_readout, "hal_readout");
    sc_signal<sc_bv<1>> hal_readout_valid;
    sc_trace(Tf, hal_readout_valid, "hal_readout_valid");
    sc_signal<sc_bv<1>> hal_readout_ready;
    sc_trace(Tf, hal_readout_ready, "hal_readout_ready");
    sc_signal<sc_bv<8>> run_completed;
    sc_trace(Tf, run_completed, "run_completed");
   
    sc_clock clk("clk", sc_time(CLOCK_PERIOD, SC_NS));
    sc_signal<sc_bv<1>> clk_bv;
    sc_signal<bool> clk_b;
    sc_trace(Tf, clk_bv, "clk_bv");
    sc_signal<bool> rst;
    sc_signal<sc_bv<1>> rst_bv;
    sc_trace(Tf, rst, "rst");
    
    Clk2BV clk_to_bv ("sys_clk");
    clk_to_bv.clk(clk);
    clk_to_bv.clkout(clk_bv);

    Clk2Bool clk_to_bool ("sys_clk_bool");
    clk_to_bool.clk(clk);
    clk_to_bool.clkout(clk_b);


    // Instantiating the emulator
    ARTIQ_EMULATOR emulator = ARTIQ_EMULATOR("emulator", CLOCK_PERIOD);
    emulator.clk.bind(clk);
    emulator.rst.bind(rst);

    // Instantiating the Deltagraph
    Rabi_Demo rabi = Rabi_Demo("rabi", Tf);   
    rabi.clk.bind(clk_b);
    rabi.rst.bind(rst);
   
    emulator.hal_cmd.bind(rabi.command_sender_1_hal_command_out_data);
    emulator.hal_cmd_valid.bind(rabi.command_sender_1_hal_command_out_valid);
    emulator.hal_cmd_ready.bind(rabi.command_sender_1_hal_command_in_ready);

    emulator.hal_readout.bind(rabi.result_aggregator_0_hal_result_in_data);
    emulator.hal_readout_valid.bind(rabi.result_aggregator_0_hal_result_in_valid);
    emulator.hal_readout_ready.bind(rabi.result_aggregator_0_hal_result_out_ready);

    //rabi.result_aggregator_0.completed_out_data.bind(run_completed);

    bool enable_trace = tracing_delay >= 0 ? true : false;
    try {
        rst_bv.write(0);
        while (sim_duration > STEP_SIZE){
            if ((tracing_delay <= 0) && (enable_trace))
                emulator.start_deep_trace();
            else 
                tracing_delay -= STEP_SIZE;
            sc_start(STEP_SIZE, SC_US, SC_EXIT_ON_STARVATION);
            sim_duration -= STEP_SIZE;
        } 
        sc_start(sim_duration, SC_US, SC_EXIT_ON_STARVATION);
        emulator.sdram.hexdump("sdram.mem");
        cout << "exiting on timeout" << endl;
    } catch (std::exception & e) {
        cerr << "exiting on error" << endl;
        cerr << e.what() << endl;
    }
    Py_Finalize();
    return 0;

}
